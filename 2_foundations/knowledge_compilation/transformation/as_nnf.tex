% \subsection{\color{blue}{NNF and Variants}}
\subsection{\color{blue}{Knowledge Compilation}}
Casting PRA model as PDAG allows to view the model a set of boolean propositional statements. Thus, any question that can be asked about the system, can be seen as a general reasoning (queries or transformations) over the knowledge base, defined by the propositional statements. A common approach to dealing with such problems is knowledge compilation.

Knowledge Compilation (KC) has emerged as a significant direction of research for addressing the computational intractability inherent in general propositional reasoning tasks. This approach, which has a long tradition in reasoning Artificial Intelligence, was notably structured and analyzed in the work of Darwiche and Marquis. KC fundamentally involves splitting the reasoning process into two distinct phases:
\begin{enumerate}
    \item An \textbf{off-line compilation phase}: In this initial phase, a knowledge base (represented, for instance, as a propositional theory or formula) is transformed or ``compiled'' into a different representation, referred to as a tractable form, or target language. The target language is specifically chosen because it supports certain desirable properties, such as tractability for specific queries (questions) or allowing polynomial time evaluation.
    \item An \textbf{on-line query-answering phase}: Once compiled, the resulting target representation is utilized to answer queries efficiently. The goal is for these query answering procedures to be polynomial time with respect to the size of the compiled representation.
\end{enumerate}
The primary rationalization behind this two-phase approach is to \textbf{shift as much of the computational overhead as possible into the off-line compilation phase}. While the compilation step itself can be computationally hard, this initial cost is amortized over the potentially large number of subsequent on-line queries. This amortized cost makes the overall reasoning process more efficient when multiple queries are anticipated on the same knowledge base.

\subsection{\color{blue}{Negation Normal Form}}
Boolean negation normal form (NNF) is a syntactic restriction for Boolean formulas such that negations (NOT operators) are applied only directly to variables and not to compound subformulas. Formally, a Boolean formula is in NNF if it is built from variables, their negations, conjunctions (AND), and disjunctions (OR), where NOT appears only as part of literals.

A boolean expression in NNF can be represented as a rooted directed acyclic graph, DAG. The leaf of the graph correspond to constants (0, 1) or literals ($a$, $\neg b$), presented in the expression. The internal nodes of the DAG correspond to AND ($\land$) and OR ($\lor$) gates. Internal gates cannot be associated with NOT gates.

In the context of knowledge compilation, NNF serves as a foundational target language. Knowledge bases compiled into NNF allow efficient model checking and form the basis for further restricted normal forms like conjunctive normal form (CNF), disjunctive normal form (DNF), Decomposable NNF (DNNF), or Deterministic DNNF (d-DNNF). NNF enables subsequent transformations and reasoning tasks to be performed with well-bounded complexity, as it ensures logical negation is ``pushed down'' to the leaves of the formula’s parse tree, simplifying subsequent manipulations.

\subsubsection{\color{blue}{Properties of NNF}}
NNFs can be classified based on adherence to particular properties/restrictions. The set of NNFs that adherece to a set of properties defines a representational language, $L$.

\paragraph{Decomposability}
An NNF is decomposable if, at every conjunction ($\land$) gate, the sets of variables feeding into the subformulas of its children are pairwise disjoint. That is, for any $\wedge$-node with children, the sets of variables involved in the subformulas rooted at those children share no variables. 
Formally, for any $\wedge$-node with children ($\alpha_1, \ldots, \alpha_n$),
\[
\mathrm{Vars}(\alpha_i) \cap \mathrm{Vars}(\alpha_j) = \emptyset \quad \forall i \neq j
\]
This property ensures tractable consistency checking and supports efficient computation on the representation. The language of Decomposable Negation Normal Form (DNNF) comprises those NNFs that are decomposable.

\paragraph{Determinism}
An NNF is deterministic if, at every disjunction ($\lor$) gate, the sets of models (i.e., assignments that make the subformulas true) computed by its children are mutually exclusive—no single assignment satisfies more than one child. 
Zero-overlap of assignments between children guarantees tractable model counting. Determinism together with decomposability yields Deterministic Decomposable Negation Normal Form (d-DNNF), which enables polytime validity, implicant, and model counting queries. SDDs (Sentential Decision Diagrams) are a strict subset of d-DNNF with additional structure.

\paragraph{Smoothness}
An NNF is smooth if, at every disjunction ($\lor$) gate, all children depend on the same set of variables (atoms). That is, for every OR-node, the set of variables in each child’s subformula is identical. Smoothness simplifies certain operations in knowledge compilation and ensures that the models of disjuncts are over a fixed set of variables. Smoothness can always be enforced on any DNNF in polynomial time without affecting succinctness. Smooth Deterministic Decomposable Negation Normal Form (sd-DNNF) enforces decomposability, determinism, and smoothness.

\paragraph{Flatness}
An NNF is flat if the circuit/tree has height at most two: the root is an AND or OR, and the children are literals or simple conjunction/disjunctions of literals. Both CNF and DNF are examples of flat NNF: In CNF, the root is AND, its children are ORs of literals (clauses); in DNF, the root is OR, its children are ANDs of literals (terms). Flatness restricts structural complexity and further subclasses are defined by additional properties: for instance, CNF requires each clause to have no repeated variables, and DNF requires each term to have unique variables.

% I give up, your table is much nicer. TIL about X column.
\begin{table}
    \centering
    \begin{tabularx}{\textwidth}{XXXXXXXXX}
        \toprule
        Formalism & Succinctness (Relative) & Flatness & Smoothness & Determinism & Decomposability & Polytime Model Enumeration (ME) & Polytime Model Counting (CT) & Polytime Essential Prime Implicant Generation (EPI) \\ \midrule
        NNF & Most succinct (equally succinct to CO-LSNNF) & $\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$ (unless P=NP) & $\circ$ (unless P=NP) & $\bullet$ \\
        DNF & Less succinct than DNNF, d-DNNF, etc. & $\surd$ & $\circ$ & $\circ$ & $\surd$ (is a subset of DNNF) & $\surd$ & $\circ$ (unless P=NP) & $\bullet$ \\
        CNF & Less succinct than MODS & $\surd$ & $\circ$ & $\circ$ & $\circ$ & $\circ$ (unless P=NP) & $\circ$ (unless P=NP) & $\bullet$ \\
        DNNF & More succinct than d-DNNF, OBDD, DNF etc. & $\circ$ (nested) & $\circ$ & $\circ$ & $\surd$ & $\surd$ & $\circ$ (unless P=NP) & $\bullet$ \\
        d-DNNF & Less succinct than DNNF, more than OBDD, MODS & $\circ$ (nested) & $\circ$ (not required for all) & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\bullet$ \\
        SDD & Strict subset of d-DNNF & $\circ$ (nested) & $\circ$ (not required for all) & $\surd$ (subset of d-DNNF) & $\surd$ (subset of d-DNNF) & $\surd$ & $\surd$ & $\bullet$ \\
        OBDD & Less succinct than DNNF, d-DNNF, more than OBDD<, MODS & $\circ$ (can be deep) & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\bullet$ \\
        \bottomrule
    \end{tabularx}
    \caption{$\surd$ - satisfied, $\circ$ - not satisfied.}
\end{table}


% \input{2_foundations/knowledge_compilation/table_summary}

% \paragrah{Succinctness}
% For any two representation languages L₁ and L₂, L₁ is less succinct than L₂ if some Boolean function has exponentially larger representation in L₁ than in L₂, with L₂ able to simulate L₁ formulas by at most a polynomial growth. Formally, L₁ <ₛ L₂. Increasing representational restrictions—by enforcing decomposability, determinism, and smoothness—generally decreases succinctness (increases size). The ordering for some common languages is: MODS <ₛ OBDD <ₛ FBDD <ₛ d-DNNF <ₛ DNNF, where each step to the right is more succinct (space-efficient) but possibly less tractable for certain operations. SDDs ``sit between'' OBDD and d-DNNF.