\subsection{\color{blue}{Knowledge Compilation}}
Casting \acrshort{pra} model as \acrshort{pdag} allows to view the model a set of boolean propositional statements. Thus, any question that can be asked about the system, can be seen as a general reasoning (queries or transformations) over the knowledge base, defined by the propositional statements. A common approach to dealing with such problems is knowledge compilation.

Knowledge Compilation has emerged as a significant direction of research for addressing the computational intractability inherent in general propositional reasoning tasks. This approach, which has a long tradition in reasoning Artificial Intelligence, was notably structured and analyzed in the work of Darwiche and Marquis. KC fundamentally involves splitting the reasoning process into two distinct phases:
\begin{enumerate}
    \item An \textbf{off-line compilation phase}: In this initial phase, a knowledge base (represented, for instance, as a propositional theory or formula) is transformed or "compiled" into a different representation, referred to as a tractable form, or target language. The target language is specifically chosen because it supports certain desirable properties, such as tractability for specific queries (questions) or allowing polynomial time evaluation.
    \item An \textbf{on-line query-answering phase}: Once compiled, the resulting target representation is utilized to answer queries efficiently. The goal is for these query answering procedures to be polynomial time with respect to the size of the compiled representation.
\end{enumerate}
The primary rationalization behind this two-phase approach is to \textbf{shift as much of the computational overhead as possible into the off-line compilation phase}. While the compilation step itself can be computationally hard, this initial cost is amortized over the potentially large number of subsequent on-line queries. This amortized cost makes the overall reasoning process more efficient when multiple queries are anticipated on the same knowledge base.

\subsection{\color{blue}{Negation Normal Form (NNF)}}
Boolean \acrfull{nnf} is a syntactic restriction for Boolean formulas such that negations (NOT operators) are applied only directly to variables and not to compound subformulas. Formally, a Boolean formula is in \acrshort{nnf} if it is built from variables, their negations, conjunctions (AND), and disjunctions (OR), where NOT appears only as part of literals.

A boolean expression in \acrshort{nnf} can be represented as a rooted directed acyclic graph, \acrshort{dag}. The leaf of the graph correspond to constants (0, 1) or literals ($a$, $\neg b$), presented in the expression. The internal nodes of the \acrshort{dag} correspond to AND ($\land$) and OR ($\lor$) gates. Internal gates cannot be associated with NOT gates.

In the context of knowledge compilation, \acrshort{nnf} serves as a foundational target language. Knowledge bases compiled into \acrshort{nnf} allow efficient model checking and form the basis for further restricted normal forms like \acrfull{cnf}, \acrfull{dnf}, \acrfull{dnnf}, or \acrfull{d-dnnf}. \acrshort{nnf} enables subsequent transformations and reasoning tasks to be performed with well-bounded complexity, as it ensures logical negation is "pushed down" to the leaves of the formula’s parse tree, simplifying subsequent manipulations.

\subsubsection{\color{blue}{Properties of \acrshort{nnf}}}
 \acrshort{nnf}s can be classified based on adherence to particular properties/restrictions. The set of  \acrshort{nnf}s that adhere to a set of properties defines a representational language, $L$ (\ref{tab:props}).

\paragraph{Decomposability}
An \acrshort{nnf} is decomposable if, at every conjunction ($\land$) gate, the sets of variables feeding into the subformulas of its children are pairwise disjoint. That is, for any $\wedge$-node with children, the sets of variables involved in the subformulas rooted at those children share no variables. 
Formally, for any $\wedge$-node with children ($\alpha_1, \ldots, \alpha_n$),
\[
\mathrm{Vars}(\alpha_i) \cap \mathrm{Vars}(\alpha_j) = \emptyset \quad \forall i \neq j
\]
This property ensures tractable consistency checking and supports efficient computation on the representation. The language of \acrshort{dnnf} comprises those \acrshort{nnf}s that are decomposable.

\paragraph{Determinism}
An \acrshort{nnf} is deterministic if, at every disjunction ($\lor$) gate, the sets of models (i.e., assignments that make the subformulas true) computed by its children are mutually exclusive—no single assignment satisfies more than one child. 
Zero-overlap of assignments between children guarantees tractable model counting. Determinism together with decomposability yields \acrfull{d-dnnf}, which enables polytime validity, implicant, and model counting queries. \acrfull{sdd}s are a strict subset of \acrshort{d-dnnf} with additional structure.

\paragraph{Smoothness}
An \acrshort{nnf} is smooth if, at every disjunction ($\lor$) gate, all children depend on the same set of variables (atoms). That is, for every OR-node, the set of variables in each child’s subformula is identical. Smoothness simplifies certain operations in knowledge compilation and ensures that the models of disjuncts are over a fixed set of variables. Smoothness can always be enforced on any \acrshort{dnnf} in polynomial time without affecting succinctness. \acrfull{sd-dnnf} enforces decomposability, determinism, and smoothness.

\paragraph{Flatness}
An \acrshort{nnf} is flat if the circuit/tree has height at most two: the root is an AND or OR, and the children are literals or simple conjunction/disjunctions of literals. Both \acrshort{cnf} and \acrshort{dnf} are examples of \acrfull{f-nnf}: In \acrshort{cnf}, the root is AND, its children are ORs of literals (clauses); in \acrshort{dnf}, the root is OR, its children are ANDs of literals (terms). Flatness restricts structural complexity and further subclasses are defined by additional properties: for instance, \acrshort{cnf} requires each clause to have no repeated variables, and \acrshort{dnf} requires each term to have unique variables.

\input{2_foundations/knowledge_compilation/transformation/classes}

\begin{landscape} 
\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
        Form & Decomposable & Deterministic & Smooth & Structured Decomposability & Strong Determinism & Flat \\ \hline
        NNF & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark \\ \hline
        CNF & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark \\ \hline
        DNF & \cmark & \cmark & \xmark & \xmark & \xmark & \cmark \\ \hline
        DNNF & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark \\ \hline
        d-DNNF & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark \\ \hline
        SDD & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark \\ \hline
        OBDD & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark \\ \hline
    \end{tabular}
    \label{tab:props}
    \caption{Properties of selected target languages.}
\end{table}

\begin{table}[ht]
    \centering
    \begin{tabularx}{1.3\textwidth}{XXXXXXXXX}
    \toprule
        Language & Succinctness & Consistency (CO) & Model Enumeration (ME) & Model Counting (CT) & Equivalence (EQ) & Conditioning & Forgetting & Boolean Combination \\ 
    \midrule
        CNF & Universal & coNP-complete & poly-delay & \#P-hard & coNP-complete & polytime & coNP-c. & polytime \\ \hline
        DNF & Universal & polytime & poly-delay & \#P-hard & coNP-complete & polytime & coNP-c. & polytime \\ \hline
        NNF & Universal & NP-complete & NP-complete & \#P-hard & coNP-complete & polytime & coNP-c. & polytime \\ \hline
        DNNF & Universal & polytime & poly-delay & \#P-hard & coNP-complete & polytime & coNP-c. & polytime \\ \hline
        d-DNNF & Less succinct & polytime & poly-delay & polytime & coNP-complete & polytime & coNP-c. & polytime \\ \hline
        SDD & Similar to d-DNNF & polytime & poly-delay & polytime & polytime* & polytime & polytime & polytime \\ \hline
        OBDD & Least succinct & polytime & poly-delay & polytime & polytime† & polytime & NP-hard & polytime \\ 
    \bottomrule
    \end{tabularx}
    \caption{Complexity in time for queries based on various target languages.}
\end{table}
\end{landscape}

% \begin{table}
%     \centering
%     \begin{tabularx}{\textwidth}{XXXXXXXXX}
%         \toprule
%         Formalism & Succinctness (Relative) & Flatness & Smoothness & Determinism & Decomposability & Polytime Model Enumeration (ME) & Polytime Model Counting (CT) & Polytime Essential Prime Implicant Generation (EPI) \\ \midrule
%         \acrshort{nnf} & Most succinct (equally succinct to CO-LSNNF) & $\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$ (unless P=NP) & $\circ$ (unless P=NP) & $\bullet$ \\
%         \acrshort{dnf} & Less succinct than \acrshort{dnnf}, \acrshort{d-dnnf}, etc. & $\surd$ & $\circ$ & $\circ$ & $\surd$ (is a subset of \acrshort{dnnf}) & $\surd$ & $\circ$ (unless P=NP) & $\bullet$ \\
%         \acrshort{cnf} & Less succinct than MODS & $\surd$ & $\circ$ & $\circ$ & $\circ$ & $\circ$ (unless P=NP) & $\circ$ (unless P=NP) & $\bullet$ \\
%         \acrshort{dnnf} & More succinct than \acrshort{d-dnnf}, OBDD, \acrshort{dnf} etc. & $\circ$ (nested) & $\circ$ & $\circ$ & $\surd$ & $\surd$ & $\circ$ (unless P=NP) & $\bullet$ \\
%         \acrshort{d-dnnf} & Less succinct than \acrshort{dnnf}, more than OBDD, MODS & $\circ$ (nested) & $\circ$ (not required for all) & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\bullet$ \\
%         SDD & Strict subset of \acrshort{d-dnnf} & $\circ$ (nested) & $\circ$ (not required for all) & $\surd$ (subset of \acrshort{d-dnnf}) & $\surd$ (subset of \acrshort{d-dnnf}) & $\surd$ & $\surd$ & $\bullet$ \\
%         OBDD & Less succinct than \acrshort{dnnf}, \acrshort{d-dnnf}, more than OBDD<, MODS & $\circ$ (can be deep) & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\bullet$ \\
%         \bottomrule
%     \end{tabularx}
%     \caption{$\surd$ - satisfied, $\circ$ - not satisfied.}
% \end{table}

% \input{2_foundations/knowledge_compilation/table_summary}

% \paragrah{Succinctness}
% For any two representation languages L₁ and L₂, L₁ is less succinct than L₂ if some Boolean function has exponentially larger representation in L₁ than in L₂, with L₂ able to simulate L₁ formulas by at most a polynomial growth. Formally, L₁ <ₛ L₂. Increasing representational restrictions—by enforcing decomposability, determinism, and smoothness—generally decreases succinctness (increases size). The ordering for some common languages is: MODS <ₛ OBDD <ₛ FBDD <ₛ d-DNNF <ₛ DNNF, where each step to the right is more succinct (space-efficient) but possibly less tractable for certain operations. SDDs ``sit between'' OBDD and d-DNNF.