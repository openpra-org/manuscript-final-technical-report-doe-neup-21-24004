\subsection{\color{blue}{DNF}}
\label{sec:event_trees_as_2_lvl_circuits}

\subsubsection{Event Tree Structures as Sum-Product Networks}
Consider a specific branch \(\omega_j\) leading to the end-state \(X_j\).  By definition, \(\omega_j\) occurs if and only if:
\begin{enumerate}
    \item The initiating event \(I\) happens: \(i=1\).
    \item For each functional event \(F_k\), the branch specifies a particular outcome (success or failure).  Suppose \(\omega_j\) includes successes for some subset of indices \(\alpha\subseteq \{1,\ldots,n\}\) and failures for the complementary indices.  We can write this as:
    \[
        \bigwedge_{k\in \alpha}  \bigl(f_{k}^{\text{succ}} = 1\bigr)
        \quad\wedge\quad
        \bigwedge_{k\notin \alpha} \bigl(f_{k}^{\text{fail}} = 1\bigr).
    \]
\end{enumerate}
Hence, the branch event \(\omega_j\) is logically equivalent to a single \emph{product term}:
\begin{equation}
\label{eq:branch_conjunction}
    \omega_j \;\equiv\; 
    \bigl(i=1\bigr)
    \;\wedge\;
    \bigwedge_{k\in \alpha} \bigl(f_k^{\text{succ}}=1\bigr)
    \;\wedge\;
    \bigwedge_{k\notin \alpha} \bigl(f_k^{\text{fail}}=1\bigr).
\end{equation}
In standard Boolean notation, each literal (e.g., \(f_k^{\text{succ}}\)) is a variable that can be 0 or 1, and the branch is the \(\land\) (AND) of those variables. An event tree describing all possible outcomes from \(I\) and the subsequent functional events can be viewed as the union (logical OR) of its disjoint branches:
\[
    \Omega \;=\; \omega_1 \;\cup\; \omega_2 \;\cup\;\cdots \;\cup\; \omega_m.
\]
In Boolean terms, this is the \(\lor\) (OR) of the product terms corresponding to each branch:
\begin{equation}
\label{eq:event_tree_disjunction}
    \Omega
    \;\equiv\;
    \omega_1
    \;\lor\;
    \omega_2
    \;\lor\;\cdots\lor\;
    \omega_m.
\end{equation}
Substituting each branch’s conjunction form (as in Eq.~\eqref{eq:branch_conjunction}) into Eq.~\eqref{eq:event_tree_disjunction} yields:
\[
    \Omega 
    \;\;=\;\;
    \Bigl[
        i \;\wedge\; \prod_{k\in \alpha_1} f_k^{\text{succ}} \;\wedge\; \prod_{k\notin \alpha_1} f_k^{\text{fail}}
    \Bigr]
    \;\;\lor\;\;
    \Bigl[
        i \;\wedge\; \prod_{k\in \alpha_2} f_k^{\text{succ}} \;\wedge\; \prod_{k\notin \alpha_2} f_k^{\text{fail}}
    \Bigr]
    \;\;\lor\;\;
    \cdots
\]
where each \(\alpha_r\) is the set of functional events that succeed along branch \(r\).

A standard \acrshort{dnf} (\acrshort{sop}) expression in Boolean algebra is
\[
    \bigl(\text{literal}_1 \;\wedge\;\text{literal}_2 \;\wedge\;\cdots\bigr)
    \;\;\lor\;\;
    \bigl(\text{literal}_{1}' \;\wedge\;\text{literal}_{2}' \;\wedge\;\cdots\bigr)
    \;\;\lor\;\;\cdots
\]
Each term in the sum (OR) is a logical AND of literals (variables or their negations). Comparing with Eq.~\eqref{eq:event_tree_disjunction}, we see that an event tree is exactly a disjunction of terms, each term being a conjunction of the initiating event \(i\) (set to 1) and the success/failure indicators for each \(F_k\). Since any negation can be encoded by stating whether \(F_k\) is \(\text{succ}\) (\(f_k^{\text{succ}}=1\)) or \(\text{fail}\) (\(f_k^{\text{fail}}=1\)), the entire event tree \(\Omega\) is in \acrshort{dnf}:
\[
    \Omega \;=\; 
    \bigvee_{j=1}^m
    \Bigl[
        \;\bigwedge_{\ell\in \Lambda_j}
        (\text{appropriate literal})
    \Bigr].
\]

\subsubsection{Tractability of Event Trees}
\label{sec:tractability_event_trees}

Within \(\operatorname{SP}\!-\)networks (sum-product networks), a sum gate provides a weighted sum of child distributions, whereas a product gate factorizes them.  An event tree can be cast as an \(\operatorname{SP}\!-\)network by feeding each branch’s literal probabilities into product gates (one per branch), then summing over all branches with a sum gate.  Once constructed, evaluating the resulting \(\operatorname{SP}\!-\)network at a specific configuration \(\mathbf{x}\) or marginalizing out some of the variables is linear in the size of that network.  Nevertheless, the tractability of event trees (and their circuit representations) heavily depends on their size and structure.  We summarize several key considerations below:

\begin{enumerate}
    \item \emph{\acrshort{dnf} size grows exponentially.}
    
    Suppose an event tree includes \(n\) functional events, each of which can succeed or fail.  In the worst case, enumerating \emph{all} possible outcome branches (i.e.\ each success/failure pattern) yields up to \(2^n\) conjunction terms.  Hence, the disjunctive normal form (\acrshort{dnf}) representation can become exponentially large.  Computing or marginalizing probabilities over such a large \acrshort{dnf} may become prohibitively expensive if \(n\) is large enough.

    \item \emph{Evaluation linear in network size.}
    
    Even though the \acrshort{dnf} itself may blow up exponentially, once the event tree is translated into an \(\operatorname{SP}\!-\)network, key inference tasks (such as evaluating it at a configuration or marginalizing over certain variables) proceed in time linear in the \emph{compiled network size}.  That said, if the underlying network has already reached exponential size in the number of events, the linear-time evaluation does not necessarily improve the overall worst-case complexity.
    
    \item \emph{Approximations abound.}
    
    In practice, analysts often employ approximations to keep event trees tractable.  One possibility is \emph{decomposability}, a core principle behind tractable probabilistic circuits whereby each product gate operates on disjoint sets of variables.  If the system decomposes (e.g.\ different safety barriers protect disjoint sets of equipment), one can evaluate probabilities without enumerating all branches.  Another common approximation is to prune paths with very low probabilities or ignore paths that only negligibly contribute to the overall risk.
\end{enumerate}

Fully enumerated event trees, regardless of being interpretable as \acrshort{dnf}/\acrshort{sp} networks, trade tractability for expressivity. The intuitive branching structure and conditional probability assignments make event trees easy to interpret. PRA analysts can read off and reason about the high-level scenario decomposition, incorporate domain knowledge, and analyze each branch explicitly.  If the number of critical functional events is moderate, enumerating all branches remains tractable. As the depth and breadth of the tree grow, any brute-force probability computation over such a large \acrshort{dnf}/\acrshort{sop} circuit is equally exponential in the worst case. Even though \(\operatorname{SP}\!-\)networks offer efficient linear-time evaluation with respect to the circuit size, the underlying circuit itself may have size exponential in \(n\).