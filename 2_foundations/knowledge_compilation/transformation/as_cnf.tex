\subsection{\color{blue}{CNF}}
Conjunctive Normal Form (CNF) is a specific subset of Negation Normal Form (NNF). CNF further restricts this structure: a CNF formula is a conjunction of clauses, where each clause is a disjunction of literals. Thus, every CNF is an NNF where the formula has depth at most two: a top-level conjunction whose direct children are disjunctions of literals. Negations never apply to anything except individual variables.

Despite computational intractability of most queries, CNF is the dominant input language for SAT solvers, which employ highly optimized heuristics far surpassing brute-force complexity in practice. Many real-world verification, synthesis, and combinatorial search problems are encoded as CNF for this reason.

\subsubsection{Key Properties}

\paragraph{Flatness}
As a formula or DAG, a CNF has depth at most two. The root is a conjunction $\wedge$ whose direct children are disjunctions $\vee$ of literals (leaf nodes).

\paragraph{Simple-disjunction}
All disjunctions operate directly on literalsâ€”there are no nested or compound subformulas inside disjunctions.

\paragraph{Closure under conjunction}
The conjunction of two CNF formulas yields another CNF formula.

\paragraph{Non-uniqueness}
CNF is not canonical. Logically equivalent formulas can have very different CNF representations due to clause or literal redundancy, reordering, or other syntactic differences.

\subsubsection{Construction and Compilation}
Constructing CNF from arbitrary Boolean formulas using Tseitin encoding or distributive laws takes $(\mathcal{O}(|\varphi|))$ time and space, potentially with introduction of auxiliary variables for compactness. Any propositional formula can be converted to an equisatisfiable CNF using methods such as Tseitin encoding, which can be performed in $(\mathcal{O}(|\varphi|))$ time and size for a formula $(\varphi)$. This transformation ensures that the original and resulting CNF formulas have the same satisfiability, though logical equivalence is not guaranteed.

\subsubsection{Query Complexity}

\paragraph{Implicant Query (IM)}
Checking whether a term implies a CNF formula can be done in $(\mathcal{O}(|\text{term}| + |\text{CNF}|))$ time.

\paragraph{Satisfiability (Consistency, CO)}
Determining satisfiability of a general CNF formula is NP-complete; the best algorithms run in time $(\mathcal{O}(2^n))$ in the worst case, where $(n)$ is the number of variables, though modern SAT solvers perform much better in practice.

\paragraph{Validity (VA)}
Checking whether a CNF is a tautology is co-NP-complete. No polynomial-time algorithm is known unless P = NP.

\paragraph{Prime Implicant Generation}
Extracting a single prime implicant from a known model (an assignment satisfying the CNF) can be performed in polynomial time. This process involves iteratively attempting to remove each literal from the model and checking if the CNF remains satisfied. Each removal can be checked in time linear in the size of the CNF, and all removals together give a total complexity of $(\mathcal{O}(|\text{CNF}| \cdot |M|))$, where (M) is the model. With efficient algorithms, this task can be done in linear time.
\begin{enumerate}
    \item Finding any model or implicant: Equivalent to SAT, and thus NP-complete.
    \item Enumerating all prime implicants: Exponential time in the worst case; the number of prime implicants can be exponential in formula size.
    \item Recognizing essential prime implicants: NP-complete.
\end{enumerate}

\paragraph{Model Counting (CT)}
Counting the number of satisfying assignments is $\#P$-complete.
For a CNF with primal treewidth ($w$) and ($n$) clauses, model counting via dynamic programming on a tree decomposition can be done in ($\mathcal{O}(n2^w)$) time when the decomposition is given.
For a CNF with incidence treewidth ($w$) and ($N$) tree decomposition nodes, counting can be done in $(\mathcal{O}(2^w(kd+\delta)N))$, where ($d$) is maximum variable degree, ($\delta$) is multiplication time.

\paragraph{Model Enumeration (ME)}
Enumerating all models is not feasible in polynomial time in general, due to potentially exponential output size.

\paragraph{Clausal Entailment (CE), Equivalence (EQ), Sentential Entailment (SE)}
All are co-NP-complete (or worse) in general for CNF.

\subsubsection{CNF as a Source for Knowledge Compilation}
CNF serves as the standard input for compilation into tractable reasoning languages:

\paragraph{CNF to DNNF}
With given decomposition tree of width ($w$) and ($n$) clauses, can be compiled in $(\mathcal{O}(nw2^w))$ time and space. Complexity is singly exponential in treewidth and linear in formula size when width is bounded.

\paragraph{CNF to d-DNNF}
Using tools like c2d and DSHARP, for CNF with incidence treewidth ($k$) and size (n), can be compiled into DNNF of size $(\mathcal{O}(2^k n))$.

\paragraph{CNF to SDD}
For a CNF with ($n$) variables and vtree of width ($w$), bottom-up compilation yields SDD of size $(\mathcal{O}(n2^{w}))$, and can be performed in $(\mathcal{O}(nw))$ time if the vtree is fixed.

\paragraph{CNF to OBDD}
Top-down approaches with caching result in size and time $(\mathcal{O}(2^{\text{pathwidth}}))$ for OBDD, where pathwidth is a width measure related to treewidth.

\subsubsection{Compilers}
\begin{enumerate}
    \item DNNF/d-DNNF: c2d, dsharp (output size $(\mathcal{O}(2^{\text{width}} n))$)
    \item OBDD: CUDD, BuDDy (output size $(\mathcal{O}(2^{\text{pathwidth}}))$)
    \item SDD: SDD package (output size $(\mathcal{O}(n2^{w}))$)
\end{enumerate}

\subsubsection{Summary}
CNF is a flat, simple, but non-canonical subset of NNF well-suited as a source language for SAT-solvers and compilation into tractable representation languages. While most standard queries are intractable on raw CNF, the structure of CNF and the existence of efficient compilation techniques make it indispensable in practice for knowledge compilation and practical propositional reasoning.